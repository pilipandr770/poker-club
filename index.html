<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decentralized Poker</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a4d1a; color: white; }
        .container { max-width: 900px; margin: 0 auto; }
        .game-info { background: #2d5a2d; padding: 15px; margin: 10px 0; border-radius: 10px; }
        .actions { margin: 20px 0; background: #2d5a2d; padding: 15px; border-radius: 10px; }
        button { margin: 5px; padding: 10px 15px; cursor: pointer; border: none; border-radius: 5px; background: #4CAF50; color: white; font-weight: bold; }
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        input, select { margin: 5px; padding: 8px; border-radius: 5px; border: 1px solid #ccc; }
        h1 { text-align: center; color: #ffd700; }
        h2, h3 { color: #90EE90; }
        
        /* Poker table */
        .poker-table {
            background: linear-gradient(145deg, #0d4d0d, #1a6b1a);
            border: 8px solid #8B4513;
            border-radius: 150px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        }
        
        /* Cards */
        .cards-section {
            text-align: center;
            margin: 15px 0;
        }
        .card {
            display: inline-block;
            width: 60px;
            height: 85px;
            background: white;
            border-radius: 8px;
            margin: 5px;
            font-size: 18px;
            font-weight: bold;
            line-height: 85px;
            color: black;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            position: relative;
        }
        .card.red { color: #cc0000; }
        .card.black { color: #000; }
        .card.hidden {
            background: linear-gradient(135deg, #1a237e, #3949ab);
            color: transparent;
        }
        .card.hidden::after {
            content: "üÇ†";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            color: white;
        }
        .card-value {
            position: absolute;
            top: 5px;
            left: 8px;
            font-size: 14px;
            line-height: 1;
        }
        .card-suit {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            line-height: 1;
        }
        .card-value-bottom {
            position: absolute;
            bottom: 5px;
            right: 8px;
            font-size: 14px;
            line-height: 1;
            transform: rotate(180deg);
        }
        
        /* Game phases */
        .phase-indicator {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .phase {
            padding: 8px 15px;
            background: #333;
            border-radius: 20px;
            font-size: 12px;
        }
        .phase.active {
            background: #ffd700;
            color: black;
            font-weight: bold;
        }
        
        /* Player info */
        .player-info {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            margin: 10px 0;
        }
        
        /* Hand strength */
        .hand-strength {
            background: linear-gradient(90deg, #ffd700, #ff8c00);
            color: black;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            font-weight: bold;
            margin: 10px 0;
        }
        
        /* Action hints */
        .action-hint {
            background: rgba(255,215,0,0.2);
            border-left: 4px solid #ffd700;
            padding: 10px;
            margin: 10px 0;
            border-radius: 0 5px 5px 0;
        }
        
        #log { 
            background: rgba(0,0,0,0.5); 
            padding: 15px; 
            margin-top: 20px; 
            border-radius: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        #log p { margin: 5px 0; font-size: 13px; color: #90EE90; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé∞ Decentralized Texas Hold'em Poker</h1>

        <div id="wallet-info">
            <button id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
            <p id="account">Not connected</p>
        </div>

        <div class="game-info">
            <h2>Game Status</h2>
            <p id="game-status">No active game</p>
            <p id="last-game" style="margin: 6px 0;">No games created yet.</p>
            <p id="ui-version" style="margin: 6px 0; color: #aaa;">UI version: 2026-01-08-2</p>
            <p id="rpc-check" style="margin: 6px 0; color: #aaa; font-size: 0.9em;"></p>
            <div id="created-games" style="margin: 10px 0;"></div>
        </div>

        <!-- Poker Table -->
        <div class="poker-table" id="poker-table" style="display: none;">
            <!-- Phase Indicator -->
            <div class="phase-indicator" id="phase-indicator">
                <span class="phase" data-phase="0">Waiting</span>
                <span class="phase" data-phase="1">VRF</span>
                <span class="phase" data-phase="2">Pre-Flop</span>
                <span class="phase" data-phase="3">Flop</span>
                <span class="phase" data-phase="4">Turn</span>
                <span class="phase" data-phase="5">River</span>
                <span class="phase" data-phase="6">Showdown</span>
            </div>

            <!-- Community Cards -->
            <div class="cards-section">
                <h3>Community Cards</h3>
                <div id="community-cards">
                    <div class="card hidden"></div>
                    <div class="card hidden"></div>
                    <div class="card hidden"></div>
                    <div class="card hidden"></div>
                    <div class="card hidden"></div>
                </div>
            </div>

            <!-- Pot Info -->
            <div class="player-info" style="text-align: center;">
                <span style="font-size: 24px;">üí∞</span>
                <span id="pot-display" style="font-size: 20px; color: #ffd700;">Pot: 0 ETH</span>
                <span style="margin-left: 20px;">Current Bet: <span id="current-bet-display">0 ETH</span></span>
            </div>

            <!-- My Cards -->
            <div class="cards-section">
                <h3>Your Cards</h3>
                <div id="my-cards">
                    <div class="card hidden"></div>
                    <div class="card hidden"></div>
                </div>
                <div id="hand-strength-display"></div>
            </div>

            <!-- Action Hint -->
            <div class="action-hint" id="action-hint" style="display: none;">
                <strong>üí° Hint:</strong> <span id="hint-text">Waiting for game to start...</span>
            </div>

            <!-- Turn Indicator -->
            <div class="player-info" style="text-align: center;">
                <p id="turn-indicator" style="font-size: 18px;">Waiting for players...</p>
            </div>
        </div>

        <div class="actions">
            <h3>Create Game</h3>
            <input type="number" id="buyIn" placeholder="Buy-in amount (ETH)" step="0.01">
            <input type="number" id="smallBlind" placeholder="Small blind" step="0.001">
            <input type="number" id="bigBlind" placeholder="Big blind" step="0.001">
            <p id="create-hint" style="margin: 6px 0; color: #ccc;">
                Hint: Big blind must be 2x small blind. Buy-in must be at least 20x big blind.
            </p>
            <button class="needs-wallet" onclick="createGame()">Create Game</button>
        </div>

        <div class="actions">
            <h3>Join Game</h3>
            <input type="number" id="gameId" placeholder="Game ID">
            <select id="gameIdSelect" style="margin: 5px; padding: 8px;">
                <option value="">Select a created game...</option>
            </select>
            <p id="join-hint" style="margin: 6px 0; color: #333;">
                Hint: Enter a game ID to preview the required buy-in.
            </p>
            <button class="needs-wallet" onclick="joinGame()">Join Game</button>
        </div>

        <div class="actions">
            <h3>Game Actions</h3>
            <button class="needs-wallet" onclick="startGame()">Start Game</button>
            <button class="needs-wallet" onclick="fold()">Fold</button>
            <button class="needs-wallet" onclick="call()">Call</button>
            <input type="number" id="raiseAmount" placeholder="Raise amount" step="0.01">
            <button class="needs-wallet" onclick="raise()">Raise</button>
            <button class="needs-wallet" onclick="getMyCards()">Show My Cards</button>
        </div>

        <div id="log"></div>
    </div>

    <script src="./node_modules/ethers/dist/ethers.umd.min.js"></script>
    <script>
        let provider;
        let signer;
        let contract;
        let contractAddress = '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'; // fallback

        let isConnecting = false;

        function withTimeout(promise, ms, label) {
            return Promise.race([
                promise,
                new Promise((_, reject) => setTimeout(() => reject(new Error(`Timeout: ${label}`)), ms))
            ]);
        }

        // Surface unexpected browser/runtime errors in the UI log (helps debugging in MetaMask/Edge)
        window.addEventListener('unhandledrejection', (event) => {
            const reason = event?.reason;
            const message = reason?.message || String(reason || 'Unhandled promise rejection');

            // Common non-critical browser/extension autoplay warning in Chromium-based browsers
            if (/play\(\) request was interrupted by a call to pause\(\)/i.test(message) || /AbortError/i.test(message)) {
                // Avoid spamming user during normal flows
                console.warn('Ignored non-critical unhandled rejection:', message);
                return;
            }

            try { log('Unhandled promise rejection: ' + message); } catch (_) {}
        });

        window.addEventListener('error', (event) => {
            const message = event?.message || 'Unknown error';
            // Keep it lightweight; main errors already logged in catch blocks
            try { log('Runtime error: ' + message); } catch (_) {}
        });

        const HARDHAT_CHAIN_ID = '0x7a69'; // 31337

        async function ensureHardhatNetwork() {
            const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
            if (currentChainId === HARDHAT_CHAIN_ID) return;

            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: HARDHAT_CHAIN_ID }]
                });
            } catch (switchError) {
                // MetaMask can return:
                // - 4902 (unknown chain)
                // - -32603 with message 'Unrecognized chain ID "0x7a69". Try adding the chain...'
                const msg = (switchError && (switchError.message || switchError?.data?.message)) || '';
                const shouldTryAdd =
                    (switchError && switchError.code === 4902) ||
                    /unrecognized chain id/i.test(msg) ||
                    /wallet_addEthereumChain/i.test(msg);

                if (!shouldTryAdd) {
                    throw switchError;
                }

                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: HARDHAT_CHAIN_ID,
                        chainName: 'Hardhat Localhost',
                        rpcUrls: ['http://127.0.0.1:8545', 'http://localhost:8545'],
                        nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 }
                    }]
                });

                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: HARDHAT_CHAIN_ID }]
                });
            }
        }

        // Contract ABI (updated with card functions)
        const abi = [
            "function createGame(uint256 buyIn, uint256 smallBlind, uint256 bigBlind) payable returns (uint256)",
            "function joinGame(uint256 gameId) payable",
            "function startGame(uint256 gameId)",
            "function playerAction(uint256 gameId, uint8 action, uint256 raiseAmount)",
            "function getMyCards(uint256 gameId) view returns (uint8[2])",
            "function getCommunityCards(uint256 gameId) view returns (uint8[5], uint8 revealed)",
            "function getGameInfo(uint256 gameId) view returns (uint256 buyIn, uint256 pot, uint256 currentBet, uint8 phase, uint8 playerCount, uint8 activePlayers, uint8 currentPlayer, bool deckGenerated)",
            "function isPlayerInGame(uint256 gameId, address player) view returns (bool)",
            "function gameCounter() view returns (uint256)",
            "function playerIndex(uint256 gameId, address player) view returns (uint8)",
            "event GameCreated(uint256 indexed gameId, uint256 buyIn, uint256 smallBlind, uint256 bigBlind)"
        ];

        // Mock VRF ABI (for local testing)
        const mockVrfAbi = [
            "function fulfillLastRequest()",
            "function lastRequestId() view returns (uint256)"
        ];

        let mockVrfContract = null;
        let mockVrfAddress = null;

        // Card conversion utilities
        const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const SUIT_NAMES = ['Spades', 'Hearts', 'Diamonds', 'Clubs'];
        const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        function cardToString(cardNum) {
            if (cardNum === 0 || cardNum === undefined || cardNum === null) return null;
            const adjustedNum = Number(cardNum);
            if (adjustedNum < 0 || adjustedNum > 51) return null;
            const suit = Math.floor(adjustedNum / 13);
            const value = adjustedNum % 13;
            return { 
                display: VALUES[value] + SUITS[suit],
                value: VALUES[value],
                suit: SUITS[suit],
                suitName: SUIT_NAMES[suit],
                isRed: suit === 1 || suit === 2 // Hearts or Diamonds
            };
        }

        function renderCard(cardNum, hidden = false) {
            if (hidden || cardNum === null || cardNum === undefined) {
                return '<div class="card hidden"></div>';
            }
            const card = cardToString(cardNum);
            if (!card) return '<div class="card hidden"></div>';
            
            const colorClass = card.isRed ? 'red' : 'black';
            return `
                <div class="card ${colorClass}">
                    <span class="card-value">${card.value}${card.suit}</span>
                    <span class="card-suit">${card.suit}</span>
                    <span class="card-value-bottom">${card.value}${card.suit}</span>
                </div>
            `;
        }

        function getPhaseNameRu(phase) {
            const names = [
                '–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤',
                '–ó–∞–ø—Ä–æ—Å VRF...',
                'Pre-Flop (—Ç–æ—Ä–≥–∏)',
                'Flop (3 –∫–∞—Ä—Ç—ã)',
                'Turn (4-—è –∫–∞—Ä—Ç–∞)',
                'River (5-—è –∫–∞—Ä—Ç–∞)',
                'Showdown (–≤—Å–∫—Ä—ã—Ç–∏–µ)',
                '–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞'
            ];
            return names[phase] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
        }

        function getActionHint(phase, isMyTurn, deckGenerated) {
            if (!deckGenerated && phase >= 2) {
                return '‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–ª–æ–¥—ã (VRF)...';
            }
            if (phase === 0) return '‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤. –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 2 –∏–≥—Ä–æ–∫–∞.';
            if (phase === 1) return '‚è≥ –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —á–∏—Å–ª–∞ —É VRF –æ—Ä–∞–∫—É–ª–∞...';
            if (phase === 7) return 'üèÜ –ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!';
            if (phase === 6) return 'üÉè Showdown! –ü–æ–∫–∞–∂–∏—Ç–µ –∫–∞—Ä—Ç—ã –∏–ª–∏ —Å–±—Ä–æ—Å—å—Ç–µ.';
            
            if (!isMyTurn) return '‚è≥ –û–∂–∏–¥–∞–π—Ç–µ —Å–≤–æ—é –æ—á–µ—Ä–µ–¥—å...';
            
            return 'üéØ –í–∞—à —Ö–æ–¥! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ: Fold (—Å–±—Ä–æ—Å), Call (—É—Ä–∞–≤–Ω—è—Ç—å) –∏–ª–∏ Raise (–ø–æ–≤—ã—Å–∏—Ç—å).';
        }

        function evaluateHandStrength(myCards, communityCards) {
            // Simple hand evaluation hint (not full poker logic, just basic guidance)
            if (!myCards || myCards.length < 2) return null;
            
            const card1 = cardToString(myCards[0]);
            const card2 = cardToString(myCards[1]);
            if (!card1 || !card2) return null;

            const v1 = VALUES.indexOf(card1.value);
            const v2 = VALUES.indexOf(card2.value);
            const highCard = Math.max(v1, v2);
            const isPair = v1 === v2;
            const isSuited = card1.suitName === card2.suitName;
            const isConnected = Math.abs(v1 - v2) === 1;
            
            let strength = '';
            let hint = '';
            
            if (isPair) {
                if (highCard >= 10) { strength = 'üî• –°–∏–ª—å–Ω–∞—è –ø–∞—Ä–∞!'; hint = '–£ –≤–∞—Å –≤—ã—Å–æ–∫–∞—è –ø–∞—Ä–∞ - –∏–≥—Ä–∞–π—Ç–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ!'; }
                else if (highCard >= 6) { strength = 'üëç –°—Ä–µ–¥–Ω—è—è –ø–∞—Ä–∞'; hint = '–•–æ—Ä–æ—à–∞—è —Ä—É–∫–∞, –Ω–æ –±—É–¥—å—Ç–µ –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã.'; }
                else { strength = 'ü§î –°–ª–∞–±–∞—è –ø–∞—Ä–∞'; hint = '–ú–∞–ª–µ–Ω—å–∫–∞—è –ø–∞—Ä–∞ - –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ñ–ª–æ–ø–∞.'; }
            } else if (highCard >= 11 && (v1 >= 9 || v2 >= 9)) {
                strength = 'üí™ –í—ã—Å–æ–∫–∏–µ –∫–∞—Ä—Ç—ã';
                hint = '–°–∏–ª—å–Ω—ã–µ –∫–∞—Ä—Ç—ã. –ú–æ–∂–Ω–æ –∏–≥—Ä–∞—Ç—å.';
            } else if (isSuited && isConnected) {
                strength = 'üåà Suited connectors';
                hint = '–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª –¥–ª—è —Ñ–ª–µ—à–∞ –∏–ª–∏ —Å—Ç—Ä–∏—Ç–∞!';
            } else if (isSuited) {
                strength = '‚ô† –û–¥–Ω–æ–º–∞—Å—Ç–Ω—ã–µ';
                hint = '–ï—Å—Ç—å —à–∞–Ω—Å —Å–æ–±—Ä–∞—Ç—å —Ñ–ª–µ—à.';
            } else if (isConnected) {
                strength = '‚ÜîÔ∏è –ö–æ–Ω–Ω–µ–∫—Ç–æ—Ä—ã';
                hint = '–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª –¥–ª—è —Å—Ç—Ä–∏—Ç–∞.';
            } else if (highCard >= 10) {
                strength = 'üëå –ï—Å—Ç—å –≤—ã—Å–æ–∫–∞—è';
                hint = '–û–¥–Ω–∞ –≤—ã—Å–æ–∫–∞—è –∫–∞—Ä—Ç–∞ - –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ.';
            } else {
                strength = '‚ùå –°–ª–∞–±—ã–µ –∫–∞—Ä—Ç—ã';
                hint = '–°–ª–∞–±–∞—è —Ä—É–∫–∞. –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ fold.';
            }

            return { strength, hint };
        }

        let currentGameId = null;
        let gameUpdateInterval = null;

        const CREATED_GAMES_STORAGE_KEY = 'poker.createdGames';

        function loadCreatedGames() {
            try {
                const raw = localStorage.getItem(CREATED_GAMES_STORAGE_KEY);
                if (!raw) return [];
                const parsed = JSON.parse(raw);
                return Array.isArray(parsed) ? parsed : [];
            } catch (_) {
                return [];
            }
        }

        function saveCreatedGames(games) {
            try {
                localStorage.setItem(CREATED_GAMES_STORAGE_KEY, JSON.stringify(games));
            } catch (_) {
                // ignore
            }
        }

        function renderCreatedGamesSelect() {
            const selectEl = document.getElementById('gameIdSelect');
            if (!selectEl) return;

            const games = loadCreatedGames();
            // Keep first placeholder option
            selectEl.innerHTML = '<option value="">Select a created game...</option>';

            for (const g of games) {
                const opt = document.createElement('option');
                opt.value = String(g.id);
                const label = `Game ${g.id} (buyIn ${g.buyInEth} ETH, SB ${g.sbEth}, BB ${g.bbEth})`;
                opt.textContent = label;
                selectEl.appendChild(opt);
            }
        }

        function renderCreatedGamesList() {
            const host = document.getElementById('created-games');
            if (!host) return;

            const games = loadCreatedGames();
            if (!games.length) {
                host.innerHTML = '';
                return;
            }

            const items = games
                .map(g => {
                    const id = String(g.id);
                    const label = `#${id} (buyIn ${g.buyInEth} ETH, SB ${g.sbEth}, BB ${g.bbEth})`;
                    return `<button data-gameid="${id}" style="margin: 3px; padding: 6px 10px;">${label}</button>`;
                })
                .join('');

            host.innerHTML = `<div style="margin: 6px 0; color: #333;">Created games (click to select):</div>${items}`;

            host.querySelectorAll('button[data-gameid]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const id = btn.getAttribute('data-gameid');
                    const gameIdEl = document.getElementById('gameId');
                    if (gameIdEl) gameIdEl.value = id;
                    const selectEl = document.getElementById('gameIdSelect');
                    if (selectEl) selectEl.value = id;
                    updateJoinHint();
                });
            });
        }

        function addCreatedGameToList(entry) {
            const games = loadCreatedGames();
            if (!games.some(g => String(g.id) === String(entry.id))) {
                games.unshift(entry);
                // cap list size
                if (games.length > 25) games.length = 25;
                saveCreatedGames(games);
            }
            renderCreatedGamesSelect();
            renderCreatedGamesList();
        }

        function setWalletDependentEnabled(enabled) {
            document.querySelectorAll('.needs-wallet').forEach(btn => {
                btn.disabled = !enabled;
            });
        }

        function requireConnected() {
            if (!provider || !signer || !contract) {
                log('Connect wallet first');
                return false;
            }
            return true;
        }

        document.getElementById('gameIdSelect')?.addEventListener('change', (e) => {
            const v = e.target?.value;
            if (!v) return;
            const gameIdEl = document.getElementById('gameId');
            if (gameIdEl) gameIdEl.value = v;
            updateJoinHint();
        });

        // Render any previously created games (localStorage)
        renderCreatedGamesSelect();
        renderCreatedGamesList();

        // Default: disable game actions until wallet is connected
        setWalletDependentEnabled(false);

        async function loadDeploymentAddress() {
            try {
                const res = await fetch('./deployments/localhost.json', { cache: 'no-store' });
                if (!res.ok) return;
                const json = await res.json();
                const addr = json?.contracts?.DecentralizedPokerVRF?.address;
                if (addr && typeof addr === 'string') {
                    contractAddress = addr;
                    log('Loaded contract address: ' + contractAddress);
                }
                // Load Mock VRF address for local testing
                const vrfAddr = json?.contracts?.MockVRFCoordinatorV2Plus?.address;
                if (vrfAddr && typeof vrfAddr === 'string') {
                    mockVrfAddress = vrfAddr;
                    console.log('Loaded Mock VRF address: ' + mockVrfAddress);
                }
            } catch (_) {
                // ignore and keep fallback
            }
        }

        // best-effort load of the latest deployment info
        loadDeploymentAddress();

        // Diagnostic: test if Hardhat RPC is reachable from the browser
        async function testRpcConnection() {
            const rpcCheckEl = document.getElementById('rpc-check');
            try {
                const res = await fetch('http://127.0.0.1:8545', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ jsonrpc: '2.0', method: 'eth_blockNumber', params: [], id: 1 })
                });
                if (res.ok) {
                    if (rpcCheckEl) rpcCheckEl.textContent = 'RPC check: 127.0.0.1:8545 reachable ‚úì';
                } else {
                    if (rpcCheckEl) rpcCheckEl.textContent = 'RPC check: 127.0.0.1:8545 responded with error';
                }
            } catch (e) {
                if (rpcCheckEl) rpcCheckEl.textContent = 'RPC check: Cannot reach 127.0.0.1:8545 (CORS or node not running)';
            }
        }
        testRpcConnection();

        async function connectWallet() {
            if (isConnecting) return;
            isConnecting = true;

            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) connectBtn.disabled = true;

            const accountEl = document.getElementById('account');
            if (accountEl) accountEl.textContent = 'Connecting...';

            // Keep actions disabled until we fully finish setup
            setWalletDependentEnabled(false);

            console.log('Attempting to connect wallet...');
            if (typeof window.ethereum !== 'undefined') {
                console.log('window.ethereum found');
                try {
                    console.log('Requesting accounts...');
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    console.log('Accounts requested successfully');

                    // Create provider/signer on whatever network the wallet is currently on.
                    provider = new ethers.BrowserProvider(window.ethereum);
                    signer = await provider.getSigner();
                    contract = new ethers.Contract(contractAddress, abi, signer);

                    // Show *something* immediately so the UI doesn't look stuck.
                    try {
                        const address = await withTimeout(signer.getAddress(), 2000, 'getAddress');
                        if (accountEl) accountEl.textContent = `Connected: ${address} | Checking network...`;
                    } catch (_) {
                        // ignore
                    }

                    // Best-effort switch to Hardhat network; if user rejects, we still stay connected.
                    try {
                        await withTimeout(ensureHardhatNetwork(), 5000, 'wallet network switch');
                    } catch (switchErr) {
                        const msg = (switchErr && (switchErr.message || switchErr?.data?.message)) || 'Network switch rejected';
                        log('Note: could not switch network automatically (or it is pending). ' + msg);
                    }

                    // Re-init after potential chain switch.
                    provider = new ethers.BrowserProvider(window.ethereum);
                    signer = await provider.getSigner();
                    contract = new ethers.Contract(contractAddress, abi, signer);

                    // Refresh status (with internal per-call timeouts). Never fail the whole connect just because status is slow.
                    await safeUpdateWalletStatus();
                } catch (error) {
                    console.error('Error connecting wallet:', error);
                    const msg = error?.shortMessage || error?.reason || error?.message || 'Unknown error';
                    log('Error connecting wallet: ' + msg);
                    if (accountEl) accountEl.textContent = 'Not connected';
                }
            } else {
                console.error('window.ethereum not found');
                log('MetaMask not detected. Please install MetaMask.');
                if (accountEl) accountEl.textContent = 'MetaMask not detected';
            }

            isConnecting = false;
            if (connectBtn) connectBtn.disabled = false;
        }

        async function safeUpdateWalletStatus() {
            try {
                await updateWalletStatus();
            } catch (e) {
                console.error('updateWalletStatus error:', e);
                const msg = e?.shortMessage || e?.reason || e?.message || 'Unknown error';
                log('Wallet status error: ' + msg);
                setWalletDependentEnabled(false);
            }
        }

        async function updateWalletStatus() {
            if (!provider || !signer) return;
            const accountEl = document.getElementById('account');

            const address = await withTimeout(signer.getAddress(), 10000, 'getAddress');

            // Update UI early so user sees progress even if RPC calls are slow.
            if (accountEl) accountEl.textContent = `Connected: ${address} | Checking network...`;

            const network = await withTimeout(provider.getNetwork(), 20000, 'getNetwork');

            let balanceEth = 'N/A';
            try {
                const balanceWei = await withTimeout(provider.getBalance(address), 20000, 'getBalance');
                balanceEth = ethers.formatEther(balanceWei);
            } catch (e) {
                console.warn('Balance fetch failed:', e);
                log('MetaMask RPC timeout. Check MetaMask network settings: RPC URL must be http://127.0.0.1:8545');
                // keep going; balance is not required to consider the wallet connected
            }

            const isHardhat = network.chainId === 31337n;

            // Only check contract code when on Hardhat; otherwise this call may be confusing/unnecessary.
            let hasContractCode = false;
            if (isHardhat) {
                try {
                    const code = await withTimeout(provider.getCode(contractAddress), 20000, 'getCode');
                    hasContractCode = !!(code && code !== '0x');
                } catch (e) {
                    console.warn('Code fetch failed:', e);
                    log('Contract code fetch timeout. Verify Hardhat node is running and MetaMask RPC URL = http://127.0.0.1:8545');
                    hasContractCode = false;
                }
            }

            if (accountEl) {
                accountEl.textContent = `Connected: ${address} | ChainId: ${network.chainId} | Balance: ${balanceEth}${balanceEth === 'N/A' ? '' : ' ETH'} | Contract: ${isHardhat ? (hasContractCode ? 'OK' : 'MISSING') : 'N/A'} (${contractAddress})`;
            }

            if (!isHardhat) {
                log('Connected, but wrong network. Please switch MetaMask to Hardhat Localhost (chainId 31337).');
                setWalletDependentEnabled(false);
                return;
            }

            if (!hasContractCode) {
                log('WARNING: No contract code at ' + contractAddress + ' on this RPC. Re-run start-and-deploy and refresh this page.');
                setWalletDependentEnabled(false);
                return;
            }

            log('Wallet connected successfully');
            console.log('Wallet connected:', address);

            setWalletDependentEnabled(true);
            updateJoinHint();
        }

        // React to MetaMask changes (account/network)
        if (typeof window.ethereum !== 'undefined' && window.ethereum?.on) {
            window.ethereum.on('accountsChanged', async () => {
                try {
                    if (provider) {
                        signer = await provider.getSigner();
                        contract = new ethers.Contract(contractAddress, abi, signer);
                        await safeUpdateWalletStatus();
                    }
                } catch (_) {
                    // ignore
                }
            });
            window.ethereum.on('chainChanged', async () => {
                try {
                    if (provider) {
                        await safeUpdateWalletStatus();
                    }
                } catch (_) {
                    // ignore
                }
            });
        }

        async function createGame() {
            if (!requireConnected()) return;
            const buyIn = document.getElementById('buyIn').value;
            const smallBlind = document.getElementById('smallBlind').value;
            const bigBlind = document.getElementById('bigBlind').value;

            if (!buyIn || !smallBlind || !bigBlind) {
                log('Please enter buy-in, small blind, and big blind amounts');
                return;
            }

            try {
                // Pre-flight validation to avoid revert
                const sbNum = Number(smallBlind);
                const bbNum = Number(bigBlind);
                const buyInNum = Number(buyIn);

                if (!Number.isFinite(sbNum) || !Number.isFinite(bbNum) || !Number.isFinite(buyInNum) || sbNum <= 0 || bbNum <= 0 || buyInNum <= 0) {
                    log('Please enter valid positive numbers');
                    return;
                }

                // Big blind must be exactly 2x small blind (within a tiny epsilon for decimals)
                const expectedBb = sbNum * 2;
                const eps = 1e-12;
                if (Math.abs(bbNum - expectedBb) > eps) {
                    log('Invalid blinds: big blind must be exactly 2√ó small blind');
                    return;
                }

                const minBuyIn = bbNum * 20;
                if (buyInNum + eps < minBuyIn) {
                    log(`Buy-in too low: must be at least 20√óBB = ${minBuyIn} ETH`);
                    return;
                }

                console.log('Creating game with:', buyIn, smallBlind, bigBlind);

                // Predict gameId (createGame uses gameCounter++ so the new id is the current counter value)
                let predictedGameId = null;
                try {
                    predictedGameId = await contract.gameCounter();
                } catch (_) {
                    // ignore
                }

                if (predictedGameId !== null && predictedGameId !== undefined) {
                    const predictedStr = predictedGameId.toString();
                    const lastEl = document.getElementById('last-game');
                    if (lastEl) lastEl.textContent = `Creating gameId: ${predictedStr} ...`;
                    const gameIdEl = document.getElementById('gameId');
                    if (gameIdEl) gameIdEl.value = predictedStr;
                    const selectEl = document.getElementById('gameIdSelect');
                    if (selectEl) selectEl.value = predictedStr;
                    updateJoinHint();
                }

                const buyInWei = ethers.parseEther(buyIn);
                const smallBlindWei = ethers.parseEther(smallBlind);
                const bigBlindWei = ethers.parseEther(bigBlind);
                console.log('Parsed values:', buyInWei.toString(), smallBlindWei.toString(), bigBlindWei.toString());
                const tx = await contract.createGame(
                    buyInWei,
                    smallBlindWei,
                    bigBlindWei,
                    { value: buyInWei }
                );
                log('CreateGame tx sent: ' + tx.hash);
                const receipt = await tx.wait();

                // Try to extract gameId from GameCreated event
                let createdGameId = null;
                try {
                    for (const l of (receipt?.logs || [])) {
                        let parsed;
                        try {
                            parsed = contract.interface.parseLog(l);
                        } catch (_) {
                            continue;
                        }
                        if (parsed && parsed.name === 'GameCreated') {
                            createdGameId = parsed.args.gameId;
                            break;
                        }
                    }
                } catch (_) {
                    // ignore
                }

                if (createdGameId !== null && createdGameId !== undefined) {
                    const idStr = createdGameId.toString();
                    const lastEl = document.getElementById('last-game');
                    if (lastEl) lastEl.textContent = `Last created gameId: ${idStr}`;
                    const gameIdEl = document.getElementById('gameId');
                    if (gameIdEl) gameIdEl.value = idStr;
                    const selectEl = document.getElementById('gameIdSelect');
                    if (selectEl) selectEl.value = idStr;

                    addCreatedGameToList({
                        id: idStr,
                        buyInEth: buyIn,
                        sbEth: smallBlind,
                        bbEth: bigBlind,
                        createdAt: Date.now()
                    });

                    updateJoinHint();
                    log('Game created successfully. gameId=' + idStr);
                    startGameUpdates(Number(idStr));
                } else {
                    // Guaranteed fallback: after createGame, gameCounter was incremented, so last id = gameCounter - 1
                    let counterAfter = null;
                    try {
                        counterAfter = await contract.gameCounter();
                    } catch (_) {
                        // ignore
                    }

                    let fallbackId = null;
                    if (counterAfter !== null && counterAfter !== undefined) {
                        try {
                            const lastId = BigInt(counterAfter.toString()) - 1n;
                            if (lastId >= 0n) fallbackId = lastId.toString();
                        } catch (_) {
                            // ignore
                        }
                    }

                    // If even that failed, fall back to predicted id (best-effort)
                    if (!fallbackId && predictedGameId !== null && predictedGameId !== undefined) {
                        fallbackId = predictedGameId.toString();
                    }

                    if (fallbackId) {
                        const lastEl = document.getElementById('last-game');
                        if (lastEl) lastEl.textContent = `Last created gameId: ${fallbackId}`;
                        const gameIdEl = document.getElementById('gameId');
                        if (gameIdEl) gameIdEl.value = fallbackId;
                        const selectEl = document.getElementById('gameIdSelect');
                        if (selectEl) selectEl.value = fallbackId;

                        addCreatedGameToList({
                            id: fallbackId,
                            buyInEth: buyIn,
                            sbEth: smallBlind,
                            bbEth: bigBlind,
                            createdAt: Date.now()
                        });

                        updateJoinHint();
                        log('Game created successfully. gameId=' + fallbackId);
                        startGameUpdates(Number(fallbackId));
                    } else {
                        log('Game created successfully (gameId not detected). Try refreshing the page and check deployments/localhost.json.');
                    }
                }
            } catch (error) {
                console.error('Full error:', error);
                log('Error creating game: ' + error.message);
            }
        }

        function updateCreateHint() {
            const hintEl = document.getElementById('create-hint');
            if (!hintEl) return;

            const buyIn = document.getElementById('buyIn')?.value;
            const smallBlind = document.getElementById('smallBlind')?.value;
            const bigBlind = document.getElementById('bigBlind')?.value;

            const sbNum = Number(smallBlind);
            const bbNum = Number(bigBlind);
            const buyInNum = Number(buyIn);

            const hasNumbers = Number.isFinite(sbNum) && Number.isFinite(bbNum) && Number.isFinite(buyInNum) && sbNum > 0 && bbNum > 0;
            if (!hasNumbers) {
                hintEl.textContent = 'Hint: Big blind must be 2√ó small blind. Buy-in must be at least 20√ó big blind.';
                return;
            }

            const minBuyIn = bbNum * 20;
            const blindsOk = Math.abs(bbNum - sbNum * 2) <= 1e-12;
            const buyInOk = Number.isFinite(buyInNum) && buyInNum >= minBuyIn - 1e-12;

            hintEl.textContent = `Rules: BB = 2√óSB (${(sbNum * 2)}). Min buy-in = 20√óBB = ${minBuyIn} ETH.` +
                ` Status: blinds ${blindsOk ? 'OK' : 'NOT OK'}, buy-in ${buyInOk ? 'OK' : 'NOT OK'}.`;
        }

        function formatDecimal(num, maxDecimals = 6) {
            if (!Number.isFinite(num)) return '';
            const fixed = num.toFixed(maxDecimals);
            return fixed.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
        }

        function setInputValueIfChanged(inputEl, nextValue) {
            if (!inputEl) return;
            const next = String(nextValue ?? '');
            if (inputEl.value !== next) inputEl.value = next;
        }

        let isSyncingBlinds = false;
        let lastBlindEdited = null; // 'sb' | 'bb'

        function maybeAutoFillBuyInFromBigBlind(bbNum) {
            const buyInEl = document.getElementById('buyIn');
            if (!buyInEl) return;

            const minBuyIn = bbNum * 20;
            const buyInNum = Number(buyInEl.value);

            // Fill if empty. If user entered too-low value, bump it only when the field is not focused.
            if (!buyInEl.value) {
                setInputValueIfChanged(buyInEl, formatDecimal(minBuyIn, 6));
                return;
            }

            const isFocused = document.activeElement === buyInEl;
            if (!isFocused && Number.isFinite(buyInNum) && buyInNum > 0 && buyInNum + 1e-12 < minBuyIn) {
                setInputValueIfChanged(buyInEl, formatDecimal(minBuyIn, 6));
            }
        }

        function syncBlindsFromSmallBlind() {
            if (isSyncingBlinds) return;
            const sbEl = document.getElementById('smallBlind');
            const bbEl = document.getElementById('bigBlind');
            if (!sbEl || !bbEl) return;

            const sbNum = Number(sbEl.value);
            if (!Number.isFinite(sbNum) || sbNum <= 0) return;

            isSyncingBlinds = true;
            const bbNum = sbNum * 2;
            setInputValueIfChanged(bbEl, formatDecimal(bbNum, 6));
            maybeAutoFillBuyInFromBigBlind(bbNum);
            isSyncingBlinds = false;
        }

        function syncBlindsFromBigBlind() {
            if (isSyncingBlinds) return;
            const sbEl = document.getElementById('smallBlind');
            const bbEl = document.getElementById('bigBlind');
            if (!sbEl || !bbEl) return;

            const bbNum = Number(bbEl.value);
            if (!Number.isFinite(bbNum) || bbNum <= 0) return;

            isSyncingBlinds = true;
            const sbNum = bbNum / 2;
            setInputValueIfChanged(sbEl, formatDecimal(sbNum, 6));
            maybeAutoFillBuyInFromBigBlind(bbNum);
            isSyncingBlinds = false;
        }

        document.getElementById('buyIn')?.addEventListener('input', updateCreateHint);
        document.getElementById('smallBlind')?.addEventListener('input', () => {
            lastBlindEdited = 'sb';
            syncBlindsFromSmallBlind();
            updateCreateHint();
        });
        document.getElementById('bigBlind')?.addEventListener('input', () => {
            lastBlindEdited = 'bb';
            syncBlindsFromBigBlind();
            updateCreateHint();
        });
        updateCreateHint();

        let joinHintTimer = null;

        async function updateJoinHint() {
            const hintEl = document.getElementById('join-hint');
            const gameIdEl = document.getElementById('gameId');
            if (!hintEl || !gameIdEl) return;

            const gameIdRaw = gameIdEl.value;
            if (!gameIdRaw) {
                hintEl.textContent = 'Hint: Enter a game ID to preview the required buy-in.';
                return;
            }

            if (!contract) {
                hintEl.textContent = 'Connect wallet to preview required buy-in.';
                return;
            }

            try {
                hintEl.textContent = 'Loading game info...';
                const info = await contract.getGameInfo(gameIdRaw);
                const buyInEth = ethers.formatEther(info.buyIn);
                hintEl.textContent = `Required buy-in for Game ${gameIdRaw}: ${buyInEth} ETH`;
            } catch (e) {
                hintEl.textContent = 'Could not load game info for this Game ID.';
            }
        }

        document.getElementById('gameId')?.addEventListener('input', () => {
            if (joinHintTimer) clearTimeout(joinHintTimer);
            joinHintTimer = setTimeout(updateJoinHint, 250);
        });

        function getValidatedGameId() {
            const gameIdRaw = document.getElementById('gameId')?.value;
            if (!gameIdRaw) {
                log('Please enter game ID');
                return null;
            }

            const gameIdNum = Number(gameIdRaw);
            if (!Number.isFinite(gameIdNum) || gameIdNum < 0 || !Number.isInteger(gameIdNum)) {
                log('Game ID must be a non-negative integer');
                return null;
            }
            return gameIdNum;
        }

        async function joinGame() {
            const gameIdRaw = document.getElementById('gameId').value;
            if (!gameIdRaw) {
                log('Please enter game ID');
                return;
            }

            const gameIdNum = Number(gameIdRaw);
            if (!Number.isFinite(gameIdNum) || gameIdNum < 0 || !Number.isInteger(gameIdNum)) {
                log('Game ID must be a non-negative integer');
                return;
            }

            if (!requireConnected()) return;

            try {
                const me = await signer.getAddress();
                const already = await contract.isPlayerInGame(gameIdNum, me);
                if (already) {
                    log('You are already in this game. Starting game view...');
                    startGameUpdates(gameIdNum);
                    return;
                }

                console.log('Joining game:', gameIdNum);
                const gameInfo = await contract.getGameInfo(gameIdNum);
                const tx = await contract.joinGame(gameIdNum, { value: gameInfo.buyIn });
                await tx.wait();
                log('Joined game successfully');
                startGameUpdates(gameIdNum);
            } catch (error) {
                console.error('joinGame error:', error);
                const msg = error?.shortMessage || error?.reason || error?.message || 'Unknown error';
                log('Error joining game: ' + msg);
            }
        }

        async function startGame() {
            if (!requireConnected()) return;
            const gameId = getValidatedGameId();
            if (gameId === null) return;
            try {
                log('Starting game...');
                const tx = await contract.startGame(gameId);
                await tx.wait();
                log('Game started, requesting VRF...');
                
                // For local testing: automatically fulfill VRF request
                await fulfillVRF();
                
                startGameUpdates(gameId);
            } catch (error) {
                log('Error starting game: ' + error.message);
            }
        }

        async function fulfillVRF() {
            if (!mockVrfAddress) {
                log('Mock VRF address not loaded - cannot auto-fulfill');
                return false;
            }
            try {
                if (!mockVrfContract) {
                    mockVrfContract = new ethers.Contract(mockVrfAddress, mockVrfAbi, signer);
                }
                log('Fulfilling VRF request...');
                const tx = await mockVrfContract.fulfillLastRequest();
                await tx.wait();
                log('VRF fulfilled - cards dealt!');
                return true;
            } catch (error) {
                log('VRF fulfill error: ' + error.message);
                return false;
            }
        }

        async function fold() {
            if (!requireConnected()) return;
            const gameId = getValidatedGameId();
            if (gameId === null) return;
            try {
                const tx = await contract.playerAction(gameId, 1, 0); // 1 = Fold
                await tx.wait();
                log('Folded');
                if (currentGameId !== null) updateGameDisplay(currentGameId);
            } catch (error) {
                log('Error folding: ' + error.message);
            }
        }

        async function call() {
            if (!requireConnected()) return;
            const gameId = getValidatedGameId();
            if (gameId === null) return;
            try {
                const tx = await contract.playerAction(gameId, 3, 0); // 3 = Call
                await tx.wait();
                log('Called');
                if (currentGameId !== null) updateGameDisplay(currentGameId);
            } catch (error) {
                log('Error calling: ' + error.message);
            }
        }

        async function raise() {
            if (!requireConnected()) return;
            const gameId = getValidatedGameId();
            if (gameId === null) return;

            const amount = document.getElementById('raiseAmount')?.value;
            if (!amount) {
                log('Please enter raise amount');
                return;
            }

            const amountNum = Number(amount);
            if (!Number.isFinite(amountNum) || amountNum <= 0) {
                log('Raise amount must be a positive number');
                return;
            }
            try {
                const tx = await contract.playerAction(gameId, 4, ethers.parseEther(amount)); // 4 = Raise
                await tx.wait();
                log('Raised to ' + amount + ' ETH');
                if (currentGameId !== null) updateGameDisplay(currentGameId);
            } catch (error) {
                log('Error raising: ' + error.message);
            }
        }

        async function getMyCards() {
            if (!requireConnected()) return;
            const gameId = getValidatedGameId();
            if (gameId === null) return;
            try {
                const cards = await contract.getMyCards(gameId);
                const card1 = cardToString(Number(cards[0]));
                const card2 = cardToString(Number(cards[1]));
                if (card1 && card2) {
                    log(`Your cards: ${card1.display} ${card2.display}`);
                } else {
                    log('Cards not dealt yet or invalid.');
                }
                // Also update the display
                await updateGameDisplay(gameId);
            } catch (error) {
                log('Error getting cards: ' + error.message);
            }
        }

        async function updateGameDisplay(gameId) {
            if (!contract) return;
            
            try {
                const info = await contract.getGameInfo(gameId);
                const phase = Number(info.phase);
                const deckGenerated = info.deckGenerated;
                const pot = ethers.formatEther(info.pot);
                const currentBet = ethers.formatEther(info.currentBet);
                const playerCount = Number(info.playerCount);
                const activePlayers = Number(info.activePlayers);
                const currentPlayer = Number(info.currentPlayer);

                // Show the poker table
                const pokerTable = document.getElementById('poker-table');
                if (pokerTable) pokerTable.style.display = 'block';

                // Update phase indicators
                document.querySelectorAll('.phase').forEach(el => {
                    const p = Number(el.dataset.phase);
                    el.classList.toggle('active', p === phase);
                });

                // Update pot display
                document.getElementById('pot-display').textContent = `Pot: ${pot} ETH`;
                document.getElementById('current-bet-display').textContent = `${currentBet} ETH`;

                // Update game status text
                document.getElementById('game-status').textContent = 
                    `Phase: ${getPhaseNameRu(phase)} | Players: ${activePlayers}/${playerCount}`;

                // Check if it's my turn
                let isMyTurn = false;
                let myIdx = -1;
                try {
                    const me = await signer.getAddress();
                    const inGame = await contract.isPlayerInGame(gameId, me);
                    if (inGame) {
                        myIdx = Number(await contract.playerIndex(gameId, me));
                        isMyTurn = (myIdx === currentPlayer) && (phase >= 2 && phase <= 5);
                    }
                } catch (_) {}

                // Update turn indicator
                const turnEl = document.getElementById('turn-indicator');
                if (phase >= 2 && phase <= 5) {
                    if (isMyTurn) {
                        turnEl.innerHTML = 'üéØ <strong style="color: #ffd700;">–í–ê–® –•–û–î!</strong>';
                    } else {
                        turnEl.textContent = `–•–æ–¥ –∏–≥—Ä–æ–∫–∞ #${currentPlayer + 1}`;
                    }
                } else if (phase === 6) {
                    turnEl.textContent = 'üÉè Showdown - –≤—Å–∫—Ä—ã—Ç–∏–µ –∫–∞—Ä—Ç';
                } else if (phase === 7) {
                    turnEl.textContent = 'üèÜ –ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
                } else {
                    turnEl.textContent = `–û–∂–∏–¥–∞–Ω–∏–µ (${playerCount} –∏–≥—Ä–æ–∫–æ–≤ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–æ—Å—å)`;
                }

                // Update my cards
                if (deckGenerated && phase >= 2) {
                    try {
                        const myCards = await contract.getMyCards(gameId);
                        const card1 = Number(myCards[0]);
                        const card2 = Number(myCards[1]);
                        
                        document.getElementById('my-cards').innerHTML = 
                            renderCard(card1) + renderCard(card2);

                        // Evaluate hand strength
                        const evaluation = evaluateHandStrength([card1, card2], []);
                        if (evaluation) {
                            document.getElementById('hand-strength-display').innerHTML = 
                                `<div class="hand-strength">${evaluation.strength}</div>
                                 <p style="color: #ccc; margin-top: 5px;">${evaluation.hint}</p>`;
                        }
                    } catch (e) {
                        document.getElementById('my-cards').innerHTML = 
                            '<div class="card hidden"></div><div class="card hidden"></div>';
                        document.getElementById('hand-strength-display').innerHTML = '';
                    }
                } else {
                    document.getElementById('my-cards').innerHTML = 
                        '<div class="card hidden"></div><div class="card hidden"></div>';
                    document.getElementById('hand-strength-display').innerHTML = 
                        '<p style="color: #888;">–ö–∞—Ä—Ç—ã –±—É–¥—É—Ç —Ä–∞–∑–¥–µ–Ω—ã –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞ –∏–≥—Ä—ã</p>';
                }

                // Update community cards
                if (phase >= 3) {
                    try {
                        const [commCards, revealed] = await contract.getCommunityCards(gameId);
                        const revealedCount = Number(revealed);
                        let html = '';
                        for (let i = 0; i < 5; i++) {
                            if (i < revealedCount) {
                                html += renderCard(Number(commCards[i]));
                            } else {
                                html += '<div class="card hidden"></div>';
                            }
                        }
                        document.getElementById('community-cards').innerHTML = html;
                    } catch (_) {
                        // Keep hidden cards
                    }
                } else {
                    document.getElementById('community-cards').innerHTML = 
                        '<div class="card hidden"></div>'.repeat(5);
                }

                // Update action hint
                const hintEl = document.getElementById('action-hint');
                const hintTextEl = document.getElementById('hint-text');
                if (hintEl && hintTextEl) {
                    hintEl.style.display = 'block';
                    hintTextEl.textContent = getActionHint(phase, isMyTurn, deckGenerated);
                }

            } catch (error) {
                console.error('Error updating game display:', error);
            }
        }

        function startGameUpdates(gameId) {
            stopGameUpdates();
            currentGameId = gameId;
            updateGameDisplay(gameId);
            gameUpdateInterval = setInterval(() => updateGameDisplay(gameId), 3000);
        }

        function stopGameUpdates() {
            if (gameUpdateInterval) {
                clearInterval(gameUpdateInterval);
                gameUpdateInterval = null;
            }
        }

        function log(message) {
            const logDiv = document.getElementById('log');
            logDiv.innerHTML += '<p>' + new Date().toLocaleTimeString() + ': ' + message + '</p>';
            logDiv.scrollTop = logDiv.scrollHeight;
        }
    </script>
</body>
</html>